//optimized code time complexit =O(n*logm)
//if this code not work due to overflow of power we need do binary search as soon as the x in func cross the value of m after loop run each time.
class Solution {
  public:
    int func(int mid,int n){
        long long x=1;
        for(int i=1;i<=n;i++){
            x=x*mid;
        }
        return x;
    }
    int nthRoot(int n, int m) {
        int low=0,high=m;
        while(low<=high){
            int mid =(low+high)/2;
            if (func(mid,n)==m) return mid;
            else if (func(mid,n)>=m) high=mid-1; //if its exceed m means we need to eliminate right row
            else low=mid+1; //if its less tha m means we need to eliminate left row
        }
        return -1;
    }
};

// brute force linear search soltuion tc= O(m*log2(n))
class Solution {
  public:
    int nthRoot(int n, int m) {
        for(int i=0;i<=m;i++){
            if(pow(i,n)==m) return i; //here we havent study code for pow(i,n) 
            else if(pow(i,n)>m){
             break;
            }
        }
        return -1;
    }
};
//code for pow(i,n) can be made using for loop or power exponentation method
